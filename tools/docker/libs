#!/bin/sh

get_host_user ()
{
  HOST_USER=`whoami`
  [ "x$HOST_USER" = "xroot" -a -n "$SUDO_USER" ] && HOST_USER=$SUDO_USER
}

get_host_os ()
{
  HOST_OS="Windows"
  [ -z "$MSYSTEM" ] && HOST_OS=$(uname)
}

get_host_virtual ()
{
  HOST_VIRTUAL=0

  [ "x$HOST_OS" != "xLinux" ] && return

  for t in product_name sys_vendor; do
    f=/sys/class/dmi/id/$t && [ -f $f ] && egrep -iq "vmware|virtualbox|qemu" $f && HOST_VIRTUAL=1 && break
  done
}

prepare_docker ()
{
  "$TOP_DIR"/tools/docker/install >&2 || exit 1

  which groups >/dev/null 2>&1 && which usermod >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    get_host_user

    groups $HOST_USER | grep -q docker
    if [ $? -ne 0 ]; then
      echo "ERR: $HOST_USER is not in docker group, please add it, and logout or reboot to let it take effect:" >&2
      echo "     $ sudo usermod -aG docker $HOST_USER" >&2
      exit 1
    else
      groups | grep -q docker
      if [ $? -ne 0 ]; then
        echo "ERR: Not work as docker group, please logout or reboot" >&2
        echo "     Without logout or reboot, please issue 'newgrp docker' as a temp solution." >&2
        exit 1
      fi
    fi
  fi
}

prepare_docker_toolbox ()
{
  if [ "x$HOST_OS" = "xWindows" ]; then
    (which docker | grep -iq 'Docker Toolbox' >/dev/null 2>&1) && DOCKER_TOOLBOX=1

    # Workaround: if both of docker toolbox and docker desktop are installed,
    # the path of docker.exe may be the one from docker desktop, use
    # docker-machine as a check here. the new docker desktop didn't provide docker-machine.

    (which docker-machine | grep -iq 'Docker Toolbox' >/dev/null 2>&1) && DOCKER_MACHINE=1 && DOCKER_TOOLBOX=1

    if [ -n "$DOCKER_MACHINE" -a -n "$DOCKER_TOOLBOX" ]; then
      docker-machine ls | grep -q default
      if [ $? -ne 0 ]; then
        log_print "Start docker toolbox"
        "$(dirname "$(which docker-machine)")"/start.sh uname
        log_end
      fi
      if [ "$(docker-machine status)" != "Running" ]; then
        log_print "Start default docker machine"
        timeout -k 2 10 docker-machine start default >&2
        log_end
      fi
    fi
  fi
}

get_screen_size ()
{
  [ -n "$SCREEN_SIZE" ] && return

  # 16:10: 640x480 800x480 1280x800 1440x900 1680x1050 1920x1200 2560x1600
  # 16:9: 960x540 1280x720 1920x1080 2560x1440
  DEF_SCREEN_SIZE=1280x720

  if [ "x$HOST_OS" = "xWindows" ]; then
    SCREEN_SIZE=$(wmic path Win32_VideoController get CurrentHorizontalResolution,CurrentVerticalResolution /format:value | sed -e ':a;N;$!ba;s/\r\n/_/g;s/[^0-9_]//g;s/_\{2,\}//g;s/_/x/g')
  else
    which xrandr >/dev/null 2>&1
    [ $? -ne 0 ] && SCREEN_SIZE=$DEF_SCREEN_SIZE && return
    pgrep Xorg >/dev/null 2>&1
    [ $? -ne 0 ] && SCREEN_SIZE=$DEF_SCREEN_SIZE && return

    SCREEN_SIZE=`xrandr --current 2>/dev/null | grep "^ .*\*" | tr -s ' ' | cut -d' ' -f2 | cut -d '_' -f1 | head -1 | tr -d -c '[0-9x]'`
    [ $? -ne 0 ] && SCREEN_SIZE=$DEF_SCREEN_SIZE && return

    current_height=`echo $SCREEN_SIZE | cut -d 'x' -f2 | tr -d -c '[0-9]'`
    for h in `xrandr --current 2>/dev/null | grep "^ [ 0-9]*x" | cut -d'x' -f2 | cut -d' ' -f1`
    do
      h=$(echo $h | tr -d -c '[0-9]')
      [ $h -lt $current_height ] && break
    done
    SCREEN_SIZE=`xrandr --current 2>/dev/null | grep "^ [ 0-9]*x"  | grep "x$h" | tr -s ' ' | cut -d' ' -f2 | cut -d '_' -f1 | head -1 | tr -d -c '[0-9x]'`
  fi

  [ -z "$SCREEN_SIZE" ] && SCREEN_SIZE=$DEF_SCREEN_SIZE
}

do_op () #op $ARG $args
{
  local op
  local ARG
  local arg
  local args

  op="$1"
  ARG="$2"
  args="$3"

  arg="'`eval echo "\\$${ARG}"`'"

  [ -z "$arg" ] && err_print "'$ARG' required for '$op'" && exit 1

  debug_print "Running ' $op $arg $args'"

  eval $op $arg $args
}

get_time ()
{
  local t=`date '+%N'`

  [ $t = "N" ] && t=`date '+%s'`

  echo $t | sed -e 's%^0*%%g'
}

get_random ()
{
  local random=$RANDOM

  if [ -n "$random" ]; then
      echo $random
  else
      random=`get_time`
      echo $(( random % 65535 ))
  fi
}

get_random_pwd ()
{
  local random

  which pwgen >/dev/null 2>&1 && pwgen -c -n -s -1 50 && exit 0

  random=$RANDOM
  [ -z "$random" ] && random=`get_time`

  echo $((random % 89273831 * 513793917553423 / 3))
}

get_browser ()
{
  log_print "Get web browser"

  local macos_chrome='/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
  local macos_safari=/Applications/Safari.app/Contents/MacOS/Safari
  local macos_firefox=/Applications/Firefox.app/Contents/MacOS/firefox
  local linux_chrome=chromium-browser
  local linux_firefox=firefox
  local deepin_browser=browser
  local win_firefox='/c/Program Files/Mozilla Firefox/firefox.exe'
  local win_chrome='/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'
  local win_edge=start

  local DEF_WEB_BROWSER=firefox
  if [ "x$HOST_OS" = "xDarwin" ]; then
    [ -f "$macos_safari" ] && DEF_WEB_BROWSER="$macos_safari"
    [ -f "$macos_firefox" ] && DEF_WEB_BROWSER="$macos_firefox"
    [ -f "$macos_chrome" ] && DEF_WEB_BROWSER="$(echo $macos_chrome | tr ' ' '-')"
  elif [ "x$HOST_OS" = "xLinux" ]; then
    for b in $linux_chrome $linux_firefox $deepin_browser
    do
      which $b >/dev/null 2>&1 && DEF_WEB_BROWSER=$b && break
    done
  else
    for b in "$win_chrome" "$win_firefox" "$win_edge"
    do
      which "$b" >/dev/null 2>&1 && DEF_WEB_BROWSER="$b" && break
    done
  fi

  do_unlock
  [ -z "$WEB_BROWSER" ] && get_var WEB_BROWSER "'$DEF_WEB_BROWSER'"
  do_lock

  if [ "x$HOST_OS" = "xDarwin" ]; then
    WEB_BROWSER="$(echo $WEB_BROWSER | tr '-' ' ')"
    if [ ! -f "$WEB_BROWSER" ]; then
      web_browser=`ls /Applications/*/Contents/MacOS/* | grep -i "$WEB_BROWSER$"`
      if [ $? -eq 0 ]; then
        WEB_BROWSER="$web_browser"
      else
        info_print "No $WEB_BROWSER found, use safari instead." && WEB_BROWSER=$macos_safari
      fi
    fi
  elif [ "x$HOST_OS" = "xLinux" ]; then
    which "$WEB_BROWSER" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      if [ x"$WEB_BROWSER" = "xfirefox" ]; then
        echo "ERR: No web browser found, are you running me in cloud? please open the 'Normal' url yourself."
        exit 1
      else
        info_print "No "$WEB_BROWSER" found, try firefox instead."
        WEB_BROWSER=firefox
        which "$WEB_BROWSER" >/dev/null 2>&1
        [ $? -ne 0 ] && echo "ERR: No "$WEB_BROWSER" found too." && exit 2
      fi
    fi
  else # Windows
    which "$WEB_BROWSER" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      if [ x"$WEB_BROWSER" = "xstart" ]; then
        echo "ERR: No web browser found, are you running me in cloud? please open the 'Normal' url yourself."
        exit 1
      else
        info_print "No "$WEB_BROWSER" found, try edge instead."
        WEB_BROWSER="$win_edge"
        which "$WEB_BROWSER" >/dev/null 2>&1
        [ $? -ne 0 ] && echo "ERR: No "$WEB_BROWSER" found too." && exit 2
      fi
    fi

  fi

  if [ "x$HOST_OS" = "xDarwin" ]; then
    __WEB_BROWSER="/usr/bin/open -a '$WEB_BROWSER'"
  else
    __WEB_BROWSER="$WEB_BROWSER"
  fi
  log_end
}

get_lab_info ()
{
  local tmp=`mktemp`
  local list="$1"
  local filter="$2"

  [ -z "$prompt" ] && prompt="Hello, Cloud Lab !"
  [ -z "$empty_prompt" ] && empty_prompt="当前没有任何 Lab 在线运行!"
  [ -z "$RELEASE_DIR" ] && prepare_export_files

  [ -n "$list" ] && "$list" $filter | grep -v "LOG:" > "$tmp"

  cat "$tmp" | awk 'BEGIN{FS=" "}{ \
        printf("Lab: %s, User: %s\n", $11, $2); \
        printf("  * VNC (Normal): '$WEB_HTTP'://%s:%s/?u=%s&p=%s\n", $3, $4, $5, $6); \
        printf("  * VNC   (View): '$WEB_HTTP'://%s:%s/?r=%s%s\n", $3, $4, $5, $7); \
        printf("  * SSH    (Web): '$WEB_HTTP'://%s:%s/?ssh=ssh://%s:%s@%s:22\n", $3, $9, $2, $10, $8); \
        }'
  echo

  [ ! -d "$RELEASE_DIR" ] && mkdir -p "$RELEASE_DIR"

  get_var HOST localhost
  info_print "Released to: $RELEASE_FILE"
  info_print "Labs online: `echo $RELEASE_FILE | sed -e \"s%$MAIN_CLOUD_LAB/$DEF_RELEASE_DIR%$WEB_HTTP://$HOST:$HOST_VNC_PORT/labs%g\"`"
  echo

  cat << EOF > "$RELEASE_FILE"
<html>
<body>
<head>
 <meta charset="UTF-8">
 <title>Cloud Lab | 泰晓实验云台</title>

 <style type="text/css">
  body { padding: 1.2em; margin: auto; overflow: auto; text-align: center; max-width: 960px; font-family: 'Lucida Grande', 'Helvetica Neue', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', 'WenQuanYi Micro Hei', sans-serif, 'SimSun', "宋体", 'Heiti', "黑体"; font-size: 1em; *font-size: small; -moz-transform: scale(1.0); -moz-transform-origin: center top 0; zoom: 1.0; }

  h1 { font-weight: 600; }
  a { text-decoration: none; outline: none; }
  p { text-align: center; }
  p.empty { line-height: 300px; }

  table { border: 1px solid #333; border-spacing: 0; border-collapse: collapse; width: 100%; }
  th, td { font-size: 95%; padding-left: 2px; padding-right: 2px; padding-top: 10px; padding-bottom: 10px;
     border: 1px solid #aaa; display: table-cell;
     text-align: center; max-width: 100px; }
  td { overflow: hidden; text-overflow: ellipsis }
  td.time { font-size: 92%; }
  tr.head { background-color: #ccc; }
  tr.odd { background-color: #eee; }
  tr.even { background-color: #fff; }
  th { font-weight: 600; }

  @media (max-width: 999px) {
    body {
        -moz-transform: scale(1.5);
        -moz-transform-origin: center top 0;
        zoom: 1.5
    }
  }
 </style>
</head>

<h1><a target="_blank" href="${WEB_HTTP}://${HOST}:6080">Cloud Lab | 泰晓实验云台</a></h1>
EOF

  # No lab running
  if [ `cat "$tmp" | wc -c | tr -d ' '` -eq 0 ]; then
    cat <<EOF >> "$RELEASE_FILE"
<p class="empty">$empty_prompt</p>
EOF

  # Labs exist
  else

    cat <<EOF >> "$RELEASE_FILE"
<p>$prompt</p>
EOF

    cat <<EOF >> "$RELEASE_FILE"
<br/>
<div style="padding-left: 30%">
<p style="text-align: left">1. <a href="https://www.cctalk.com/m/group/88948325" target="_blank">免费学习 Linux Lab 视频公开课，快速上手</a></p>
<p style="text-align: left">2. <a href="https://shop155917374.taobao.com" target="_blank">淘宝检索 “Linux Lab真盘” 购买开机即用版，免安装，无忧体验</a></p>
</div>
<br/>
EOF

    cat << EOF >> "$RELEASE_FILE"
<table>
<tr class="head"><th></th><th>Lab</th><th>VNC</th><th>VIEW</th><th>SSH</th><th>Start</th><th>End</th></tr>
EOF

    cat "$tmp" | awk 'BEGIN {FS=" "; }{                         \
        printf("<tr class=\"%s\">\n", (FNR%2 == 0) ? "odd" : "even"); \
        printf("  <td>%d</td>\n", FNR); \
        printf("  <td><a title=\"Project Homepage and Usage\" target=\"_blank\" href=\"http://tinylab.org/%s\">%s</a></td>\n", $1, $1); \
        printf("  <td><a target=\"_blank\" href=\"'$WEB_HTTP'://%s:%s/?u=%s&p=%s\">Login</a></td>\n", \
                $3, $4, $5, $6); \
        printf("  <td><a target=\"_blank\" href=\"'$WEB_HTTP'://%s:%s/?r=%s%s\">Login</a></td>\n", \
                $3, $4, $5, $7); \
        printf("  <td><a target=\"_blank\" href=\"'$WEB_HTTP'://%s:%s/?ssh=ssh://%s:%s@%s:22\">Login</a></td>\n", \
                $3, $9, $2, $10, $8); \
        printf("  <td class=\"time\">%s<br>%s</td>\n", $13, $14); \
        printf("  <td class=\"time\">%s<br>%s</td>\n", $15, $16); \
        printf("</tr>\n"); \
     }' >> "$RELEASE_FILE"


    cat <<EOF >> "$RELEASE_FILE"
</table>
EOF

  # Labs running or not, end if
  fi

  cat <<EOF >> "$RELEASE_FILE"
<div style="position:absolute; top:1em; right:1em; font-size:10px;"><img width="90px;" src="http://tinylab.org/images/sponsor/wechat-pay-admin-9.68.jpg"><br>微信扫码,赞助我们</div>
<p>Powered by <a target="_blank" href="http://tinylab.org/cloud-lab">Cloud Lab</a> !</p>

<script type="text/javascript">var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?15260089f8e103dc1cca30bcc1957b7c";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);
})();</script>

</body>
</html>
EOF

  #sync

  rm "$tmp"
}

get_xterm ()
{
   log_print "Get terminal"
   [ -z "$XTERM" ] && XTERM="`"$DOCKER_XTERM_CMD"`"
   log_end
}

notify_user ()
{
    # Notify users
    [ -z "$NOTIFY_WAIT" ] && NOTIFY_WAIT=$1
    [ -z "$NOTIFY_MSG" ] && NOTIFY_MSG="$2"
    [ $NOTIFY_WAIT -gt 0 ] && NOTIFY_MSG="$NOTIFY_MSG in $NOTIFY_WAIT seconds."
    [ -z "$LAB_NAME" ] && LAB_NAME=$3

    log_print "send '$NOTIFY_MSG' to $LAB_NAME"
    "$DOCKER_NOTIFY_CMD" $LAB_NAME "$NOTIFY_MSG"
    [ $? -eq 0 -a $NOTIFY_WAIT -gt 0 ] && sleep $NOTIFY_WAIT
    log_end
}

# time_to_seconds "10D"
time_to_seconds ()
{
  local time=$1
  local format=`echo $time | tr -d '[0-9]'`

  time=`echo $time | tr -c -d '[0-9]'`
  case $format in
    "Y" | "y")
      echo $((time * 360 * 24 * 60 * 60))
      ;;
    "M")
      echo $((time * 30 * 24 * 60 * 60))
      ;;
    "D" | "d")
      echo $((time * 24 * 60 * 60))
      ;;
    "H" | "h")
      echo $((time * 60 * 60))
      ;;
    "m")
      echo $((time * 60))
      ;;
    *)
      echo $time
      ;;
  esac
}

# time_to_seconds "10D"
time_to_strings ()
{
  local time=$1
  local format=`echo $time | tr -d '[0-9]'`
  local time=`echo $time | tr -c -d '[0-9]'`

  case $format in
    "Y" | "y")
      format='years'
      ;;
    "M")
      format='months'
      ;;
    "D" | "d")
      format='days'
      ;;
    "H" | "h")
      format='hours'
      ;;
    "m")
      format='minutes'
      ;;
    *)
      format='seconds'
      ;;
  esac

  echo "$time $format"
}
# get_starttime "20170633092133" -> "20170633 09:21:33"
get_starttime ()
{
  local lab_start="$1"

  echo $lab_start | sed -e "s/\([0-9]\{8\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1 \2:\3:\4/g"
}

# get_endtime "20171120 09:23:20" "1D" -> "20171121 09:23:20"
get_endtime ()
{
  # "20171120 09:23:20"
  local lab_start="$1"
  # 30D, 24H, 1Y, 12H, 10M
  local lab_life="$2"

  [ "$lab_life" = "0" ] && echo && exit 0

  if [ "x$HOST_OS" = "xDarwin" ]; then
    lab_start_seconds=`date -j -f "%Y%m%d %H:%M:%S" "$lab_start" "+%s"`
  else
    lab_start_seconds=`date --date="$lab_start" "+%s"`
  fi

  #echo "start_seconds: "$lab_start_seconds

  lab_life_seconds=`time_to_seconds $lab_life`

  #echo "life_seconds:" $lab_life_seconds

  lab_seconds=$((lab_start_seconds + lab_life_seconds))

  #echo "seconds: " $lab_seconds

  if [ "x$HOST_OS" = "xDarwin" ]; then
    date -j -f "%s" "$lab_seconds" "+%Y%m%d %H:%M:%S"
  else
    date "+%Y%m%d %H:%M:%S" --date="@$lab_seconds"
  fi
}

get_lab_list ()
{
  local dir="$1"
  local filter="$2"

  if [ -z "$filter" ]; then
     filter=$LAB_NAME
  else
     [ "$filter" = "all" ] && filter=".*"
  fi

  find "$dir" -maxdepth 1 -mindepth 1 -type d | grep "$filter" | sort -k 1
}

get_lab_bases ()
{
  local dir="$1"
  local filter="$2"

  get_lab_list "$dir" $filter | xargs -I{} basename "{}"
}

# Override the token map generation in wproxy
touch_record_file ()
{
  [ ! -d "$HOST_RECORD_DIR" ] && mkdir -p "$HOST_RECORD_DIR"
}

touch_release_file ()
{
  [ ! -d "$HOST_RELEASE_DIR" ] && mkdir -p "$HOST_RELEASE_DIR"
  [ ! -f "$RELEASE_FILE" ] && touch "$RELEASE_FILE"
}

touch_token_map ()
{
  [ ! -d "$LOCAL_TOKEN_DIR" ] && mkdir -p "$LOCAL_TOKEN_DIR"
  [ ! -f "$LOCAL_TOKEN_MAP" ] && touch "$LOCAL_TOKEN_MAP"
}

# run before container start to make sure the files' owner is normal user
touch_export_files ()
{
  touch_record_file
  touch_release_file
  touch_token_map
}

prepare_and_touch_export_files ()
{
  prepare_export_files
  touch_export_files
}

get_random_net ()
{
  # use one of the net in (172.16.0.0 - 172.31.255.255  (172.16/12 prefix)

  subnet=$((19 + $((`get_random` % 12))))
  echo 172.${subnet}.19.0
}

create_cloud_lab_net ()
{
  docker network ls | grep -q $VNC_NET_NAME >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    [ -z "$VNC_NET_MASK" ] && VNC_NET_MASK=16

    net_retry_count=0
    NET_RETRY_MAX=10
    while [ $net_retry_count -lt $NET_RETRY_MAX ]; do
      if [ -z "$VNC_NET" ]; then
        # Init one for the first try
        VNC_NET=172.20.19.0/$VNC_NET_MASK
      else
        # If old not work, use a random one
        VNC_NET=`get_random_net`/$VNC_NET_MASK
      fi
      VNC_NET_PREFIX=$(echo $VNC_NET | cut -d'/' -f1 | cut -d '.' -f1-$((5-$VNC_NET_MASK/8)))
      VNC_GATEWAY=${VNC_NET_PREFIX}.1

      docker network create --driver bridge --subnet=$VNC_NET --gateway=$VNC_GATEWAY $VNC_NET_NAME
      if [ $? -eq 0 ]; then
        info_print "Created network with driver: bridge, subnet: $VNC_NET, gateway: $VNC_GATEWAY" >&2
        break
      else
        warn_print "Failed to create network with driver: bridge, subnet: $VNC_NET, gateway: $VNC_GATEWAY, retry: $net_retry_count/$NET_RETRY_MAX" >&2
        net_retry_count=`expr $net_retry_count + 1`
        sleep 1
      fi
    done
    if [ $net_retry_count -eq $NET_RETRY_MAX ]; then
      echo "ERR: Failed to create network with driver: bridge, subnet: $VNC_NET, gateway: $VNC_GATEWAY, retry: $net_retry_count/$NET_RETRY_MAX" >&2
      exit 1
    fi
  else
    VNC_NET=`docker inspect --format "{{ .IPAM.Config }}" $VNC_NET_NAME | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b/[0-9]{1,2}"`
    VNC_NET_MASK=`echo $VNC_NET | cut -d'/' -f2`
    VNC_NET_PREFIX=$(echo $VNC_NET | cut -d'/' -f1 | cut -d '.' -f1-$((5-$VNC_NET_MASK/8)))
    VNC_GATEWAY=${VNC_NET_PREFIX}.1
  fi

  # Set gateway, wproxy and tproxy
  [ -z "$WPROXY_IP" ] && WPROXY_IP=${VNC_NET_PREFIX}.2
  [ -z "$TPROXY_IP" ] && TPROXY_IP=${VNC_NET_PREFIX}.3

  ## If saved ip is not in the new net ip range of docker, remove it for new generation
  get_var VNC_IP
  if [ -n "$VNC_IP" ]; then
    VNC_IP_BASE=`echo $VNC_IP | cut -d '.' -f1,2`
    echo $VNC_NET | grep -q $VNC_IP_BASE
    if [ $? -ne 0 ]; then
      unset VNC_IP
      rm "$LAB_VNC_IP"
    fi
  fi
}

prepare_export_files ()
{
  [ -z "$CLOUD_LAB_TOP_DIR" ] && CLOUD_LAB_TOP_DIR="$(echo $TOP_DIR | sed -e "s%/output/.*%%g")"
  [ -z "$MAIN_CLOUD_LAB" ] && MAIN_CLOUD_LAB="$CLOUD_LAB_TOP_DIR"

  [ -z "$TOP_TOKEN_DIR" ] && TOP_TOKEN_DIR="$MAIN_CLOUD_LAB"
  [ -z "$TOP_RECORD_DIR" ] && TOP_RECORD_DIR="$MAIN_CLOUD_LAB"
  [ -z "$TOP_RELEASE_DIR" ] && TOP_RELEASE_DIR="$MAIN_CLOUD_LAB"

  [ -z "$DEF_RECORD_DIR" ] && DEF_RECORD_DIR=recordings
  [ -z "$DEF_RELEASE_DIR" ] && DEF_RELEASE_DIR=releasings

  if [ -z "$RELEASE_DIR" ]; then
    GROUP_RELEASE_DIR=""
    if [ "$MAIN_CLOUD_LAB" != "$CLOUD_LAB_TOP_DIR" ]; then
      GROUP_LAB_DIR="`basename "$CLOUD_LAB_TOP_DIR"`"
      GROUP_RELEASE_DIR="${GROUP_LAB_DIR##*-}"
    fi

    USER_RELEASE_DIR=""
    if [ -n "$CURRENT" ]; then
      if [ "$CLOUD_LAB_TOP_DIR" != "$TOP_DIR" ]; then
        USER_LAB_DIR="`basename "$TOP_DIR"`"
        USER_RELEASE_DIR="${USER_LAB_DIR%%+*}-$(echo ${USER_LAB_DIR##*+} | cut -d'-' -f1)"
      fi
    fi

    RELEASE_DIR="$TOP_RELEASE_DIR"/$DEF_RELEASE_DIR
    [ -n "$GROUP_RELEASE_DIR" ] && RELEASE_DIR="$RELEASE_DIR"/$GROUP_RELEASE_DIR
    [ -n "$USER_RELEASE_DIR" ] && RELEASE_DIR="$RELEASE_DIR"/$USER_RELEASE_DIR
  fi

  [ -z "$RELEASE_HTML" ] && RELEASE_HTML=index.html
  [ -z "$RELEASE_FILE" ] && RELEASE_FILE="$RELEASE_DIR"/$RELEASE_HTML

  ## Share running wproxy
  ### TODO: Check LOCAL_TOKEN_MAP and REMOTE_TOKEN_MAP path for Windows and macOS
  id=$(docker ps -f name=$WPROXY_NAME -f status=running -q)
  if [ -n "$id" ]; then
    LOCAL_TOKEN_DIR="$(docker inspect -f '{{ .Mounts }}' $WPROXY_NAME | sed -e "s%.*[ \[]\([^ ]*/*$DEF_TOKEN_DIR[ :]/*$DEF_TOKEN_DIR\).*%\1%g" | awk -F ':| ' '{ printf("%s\n",$1) }')"
    [ $? -ne 0 ] && echo "ERR: Docker inspect failure" && exit 1

    if [ "x$HOST_OS" = "xDarwin" ]; then
      LOCAL_TOKEN_DIR=$(echo "$LOCAL_TOKEN_DIR" | sed -e "s%^/host_mnt%%g")
    elif [ "x$HOST_OS" = "xLinux" ]; then
      LOCAL_TOKEN_DIR="$LOCAL_TOKEN_DIR"
    else # Windows
      LOCAL_TOKEN_DIR=$(echo "$LOCAL_TOKEN_DIR" | sed -e "s%^/run/desktop/mnt/host%%g")
    fi

    #echo $LOCAL_TOKEN_DIR >&2
  fi

  if [ -z "$LOCAL_TOKEN_DIR" -o ! -d "$LOCAL_TOKEN_DIR" ]; then
    LOCAL_TOKEN_DIR="$TOP_TOKEN_DIR"/$DEF_TOKEN_DIR
  fi

  LOCAL_TOKEN_MAP="$LOCAL_TOKEN_DIR"/local_map
  REMOTE_TOKEN_MAP="$LOCAL_TOKEN_DIR"/remote_map

  # Init variable for export command
  HOST_RECORD_DIR="$TOP_RECORD_DIR"/$DEF_RECORD_DIR
  HOST_RELEASE_DIR="$TOP_RELEASE_DIR"/$DEF_RELEASE_DIR
  HOST_TOKEN_DIR="$LOCAL_TOKEN_DIR"
}

prepare_cloud_lab_net ()
{
  # Create cloud lab subnet
  if [ "x$HOST_OS" = "xWindows" ]; then
    docker ps >/dev/null 2>&1
    docker_exists_code=$?
  else
    docker info >/dev/null 2>&1
    docker_exists_code=$?
  fi
  if [ $docker_exists_code -eq 0 ]; then
    create_cloud_lab_net
  else
    docker info | grep -A2 -i Server >&2
    echo >&2
    echo "ERR: Docker not work well, Please let docker work at first" >&2
    echo >&2
    exit 1
  fi
}

add_sharedfolder ()
{
  # Get path of vbvm
  if [ -n "$VBOX_MSI_INSTALL_PATH" ]; then
    VBOX="$VBOX_MSI_INSTALL_PATH"
  elif [ -n "$VBOX_INSTALL_PATH" ]; then
    VBOX="$VBOX_INSTALL_PATH"
  else
    VBOX="$(reg query HKEY_LOCAL_MACHINE\\SOFTWARE\\Oracle\\VirtualBox //v InstallDir | grep InstallDir | awk '{print substr($0, index($0,$3))}')"
  fi
  VBVM="/$(echo $VBOX | sed 's/\\/\//g' | sed 's/://')VBoxManage.exe"

  if [ -f "$VBVM" ]; then

    # Share current working directory to virtualbox
    hostpath="\\\\?\\$(cd "$TOP_DIR" && pwd -W | cut -d '/' -f1)\\"
    sharedname="$(cd "$TOP_DIR" && pwd | cut -d '/' -f2)"

    "$VBVM" showvminfo default | grep -i -A10 "Shared folders" | grep -q "Name: '$sharedname', Host path:"
    if [ $? -ne 0 ]; then
      # Restart to let new added sharedfolder work
      status=$(docker-machine status)
      [ "$status" = "Running" ] && docker-machine stop default >&2

      # Add current working volume as sharedfolder and let it automount
      "$VBVM" sharedfolder add default --name="$sharedname" --hostpath="$hostpath" --automount

      # Enable symlink, still need to set with secpol.msc (may missing, require to run tools/windows/gpedit-enabler.bat as administrator)
      "$VBVM" setextradata default VBoxInternal2/SharedFoldersEnableSymlinksCreate/$sharedname 1

      # Restart to let new added sharedfolder work
      log_print "Start default docker machine"
      timeout -k 2 10 docker-machine start default >&2
      log_end
    fi
  else
    echo "ERR: Can not find virtualbox, did you install it?" >&2
    echo "ERR: If there is a virtualbox, please add '$hostpath' as sharedfolder for virtualbox and mount it as '$remotepath' as automount and permanently." >&2
    exit 1
  fi
}

get_images() { find "$CONFIGS_DIR" -name "name" | xargs -I{} cat "{}" | sort -u; }
get_labs() { ls "$CONFIGS_DIR" | tr -s ' '; }
